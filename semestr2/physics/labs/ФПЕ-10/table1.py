import numpy as np # Задля обробки масивів даних
from tabulate import tabulate # Задля красивоговиводу таблиці

PERIOD = 0.4 # Обчислений період, сек
R_K = 63.0058 # Обчислений опір котушки індуктивності, Ом

lamda_table = [] # Список логарифмічних декрементів для всіх значень опору R_m
beta_table = [] # Список коефіцієнтів загасання для всіх значень опору R_m, 1/сек
L_table = [] # Список значень індуктивності для всіх значень опору R_m, Гн
C_table = [] # Список значень ємності для всіх значень опору R_m, мкФ
R_table = [] # Список значень загального опору для всіх значень опору R_m, Ом

MAIN_table_data = [] # Загальний список даних для таблиці

# Виміряні значення 3 амплітуд для різних значень опору R_m (змінюється з кожним рядком)
A_data = np.array([

    [5.4547, 4.5516, 3.8292],
    [4.8769, 3.6485, 2.7093],
    [4.3710, 2.8899, 1.8785],
    [3.9014, 2.2758, 1.3366],
    [3.4679, 1.8423, 0.9392],
    [3.0706, 1.4450, 0.6864]

])

# Значення опоів R_m з МО (магазину опорів), Ом
R_m_table = np.array([

    [100],
    [200],
    [300],
    [400],
    [500],
    [600]

])

# Обчислюємо логарифмічні декременти для кожної пари, та потім комбінуємо їх до одного значення
for row in A_data:

    # Розраховуємо логарифми для всіх пар
    val1 = np.log(row[0] / row[1])
    val2 = np.log(row[0] / row[2])
    val3 = np.log(row[1] / row[2])

    # Середнє арифметичне трьох значень
    mean_val = np.mean([val1, val2, val3])

    # Додаємо в список
    lamda_table.append(mean_val)

# Перетворюємо список на масив (стовпець)
lamda_table = np.array(lamda_table).reshape(-1, 1)

# Обчислюємо коефіцієнт згасання, поділивши кожен елемент масиву логарифмічних декрементів на період, 1/сек
beta_table = lamda_table / PERIOD

# Обчислюємо загальний опір, додавши до R_m значення r_k, опору котушки індуктивності, Ом
R_table = R_m_table + R_K

# Обчислюємо значення індуктивності для кожного значення опору R_m, Гн
for i, lambda_val in enumerate(lamda_table, start=0):

    R = R_table[i][0]
    L = PERIOD * R / (2*lambda_val)
    L_table.append(L)

# Перетворюємо список на масив (стовпець)
L_table = np.array(L_table).reshape(-1, 1)

# Обчислюємо значення ємності з кожного значення індуктивності L, мкФ
for L_value in L_table:

    C_value = PERIOD**2 / (4 * np.pi**2 * L_value) * 1e6
    C_table.append(C_value)

# Перетворюємо список на масив (стовпець)
C_table = np.array(C_table).reshape(-1, 1)

# Додаємо всі обчислені значення до загального списку даних для таблиці
for R_m_val, lambda_val, beta_val, L_val, C_val, R_val in zip(R_m_table, lamda_table, beta_table, L_table, C_table, R_table):

    MAIN_table_data.append([R_m_val[0], "...", lambda_val[0], beta_val[0], L_val[0], C_val[0], R_val[0]])

# Виводимо таблицю
print(tabulate(
    MAIN_table_data,
    headers=["R_m, Ом", "...", "lambda", "beta, c^(-1)", "L, Гн", "C, мкФ", "R, Ом"],        # назва стовпців
    tablefmt="fancy_grid",    # «красиві» подвійні рамки
    floatfmt=".4"           # науковий формат чисел (або ".6f" для звичайного)
))

L_mean = np.mean(L_table) # Обчислення середнього значення індуктивності L, Гн
C_mean = np.mean(C_table) # Обчислення середнього значення ємності C, мкФ
R_critical = 2 * np.sqrt(L_mean / C_mean * 1e6) - R_K # Обчислення критичного опору R, Ом

# Виводимо середні обчисленні значення індуктивності L, Гн, ємності C, мкФ та критичного опору R, Ом
print(f"\nСередній значення L = {L_mean:.4} Гн")
print(f"Середній значення C = {C_mean:.4} мкФ")
print(f"Критичний опір R = {round(R_critical, 1)} Ом")