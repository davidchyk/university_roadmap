import numpy as np # Задля обробки масивів даних
from tabulate import tabulate # Задля красивоговиводу таблиці

R_K = 63.0058 # Обчислений опір котушки індуктивності, Ом
VERTICAL_PRICE = 2.26 # Вертикальна ціна коливань, В

lambda_table = [] # Список логарифмічних декрементів значень I_1, I_2, I_3, для всіх значень опору R_m
I_table = [] # Список значень обчислених сил струмів, мА
R_table = [] # Список значень загального опору для всіх значень опору R_m, Ом
delta_I_table = [] # Список значень похибок вимірювання горионтальних напргуг для кожного зі значень опору R_m (через зміну масштабування)
delta_I_lambda_table = [] # Список значень похибок вимірювання логарифмічних декрементів для кожного зі значень опору R_m
delta_U_lambda_table = [] # Список значень похибок вимірювання логарифмічних декрементів для кожного зі значень вертикальної напруги

MAIN_table_data = [] # Загальний список даних для таблиці

# Масив обчислених горизонтальних напруг для кожного значення опору R_m (змінюється з кожним рядком)
horizontal_U = np.array([

    [0.1877, 0.1570, 0.1310],
    [0.3275, 0.2443, 0.1810],
    [0.4234, 0.2831, 0.1905],
    [0.4923, 0.2892, 0.1721],
    [0.5295, 0.2858, 0.1471],
    [0.5471, 0.2563, 0.1183]

])

# Значення вертикальної напруги для кожного значення опору R_m (змінюється з кожним рядком)
vertical_U = np.array([

    [5.4547, 4.5516, 3.8292],
    [4.8769, 3.6485, 2.7093],
    [4.3710, 2.8899, 1.8785],
    [3.9014, 2.2758, 1.3366],
    [3.4679, 1.8423, 0.9392],
    [3.0706, 1.4450, 0.6864]

])

# Значення опоів R_m з МО (магазину опорів), Ом
R_m_table = np.array([

    [100],
    [200],
    [300],
    [400],
    [500],
    [600]

])

# Обчислюємо загальний опір, додавши до R_m значення r_k, опору котушки індуктивності, Ом
R_table = R_m_table + R_K

# Обчислюємо значення сил струмів, поділивши кожен елемент масиву горизонтальних напруг на значення відповідного опору R_m, мА
I_table = horizontal_U / R_m_table * 1000

# Обчислюємо логарифмічні декременти для кожної пари, та потім комбінуємо їх до одного значення
for row in horizontal_U:

    # Розраховуємо логарифми для всіх пар
    val_12 = np.log(row[0] / row[1])
    val_13 = np.log(row[0] / row[2])
    val_23 = np.log(row[1] / row[2])

    # Середнє арифметичне трьох значень
    mean_val = np.mean([val_12, val_13, val_23])

    # Додаємо в список
    lambda_table.append(mean_val)

# Перетворюємо список на масив (стовпець)
lambda_table = np.array(lambda_table).reshape(-1, 1)

# Додаємо всі обчислені значення до загального списку даних для таблиці
for R_m_val, R_val, I_val, lambda_val in zip(R_m_table, R_table, I_table, lambda_table):

    MAIN_table_data.append([R_m_val[0], R_val[0], "...", I_val[0], I_val[1], I_val[2], lambda_val[0]])

# Список значень похибок вимірювання горионтальних напргуг (множимо 0.2 до кожного значення за формулою похибки для екранів осцилографа)
delta_I_table = 0.2 * np.array([

    [0.06],
    [0.11],
    [0.17],
    [0.22],
    [0.26],
    [0.31]

])

# Обчислюємо похибки вимірювання логарифмічних декрементів для кожного зі значень опору R_m
for i, row in enumerate(horizontal_U):

    # Знаходимо похибку вимірювання логарифмічних декрементів для всіх 3 пар
    delta_lambda_val_12 = np.sqrt(delta_I_table[i][0]**2 / row[0] + delta_I_table[i][0]**2 / row[1])
    delta_lambda_val_13 = np.sqrt(delta_I_table[i][0]**2 / row[0] + delta_I_table[i][0]**2 / row[2])
    delta_lambda_val_23 = np.sqrt(delta_I_table[i][0]**2 / row[1] + delta_I_table[i][0]**2 / row[2])

    # Обчислюємо середнє значення похибки вимірювання логарифмічних декрементів
    mean_delta_lambda_val = np.mean([delta_lambda_val_12, delta_lambda_val_13, delta_lambda_val_23])

    # Додаємо в список
    delta_I_lambda_table.append(mean_delta_lambda_val)

# Обчислюємо загальне середнє значення похибки вимірювання логарифмічних декрементів
delta_I_lambda_value = np.mean(delta_I_lambda_table)

for row in vertical_U:

    # Розраховуємо логарифмічний декремент для всіх 3 пар
    val_12 = np.sqrt((0.2 * VERTICAL_PRICE)**2 / row[0] + (0.2 * VERTICAL_PRICE)**2 / row[1])
    val_13 = np.sqrt((0.2 * VERTICAL_PRICE)**2 / row[0] + (0.2 * VERTICAL_PRICE)**2 / row[2])
    val_23 = np.sqrt((0.2 * VERTICAL_PRICE)**2 / row[1] + (0.2 * VERTICAL_PRICE)**2 / row[2])

    # Середнє арифметичне трьох значень
    mean_val = np.mean([val_12, val_13, val_23])

    # Додаємо в список
    delta_U_lambda_table.append(mean_val)

# Обчислюємо загальне середнє значення похибки вимірювання логарифмічних декрементів
delta_U_lambda_value = np.mean(delta_U_lambda_table)

# Виводимо таблицю
print(tabulate(
    MAIN_table_data,
    headers=["R_m, Ом", "R_m + r_k, Ом", "...", "I_1, мА", "I_2, мА", "I_3, мА", "lambda"],        # назва стовпців
    tablefmt="fancy_grid",    # «красиві» подвійні рамки
    floatfmt=".4"           # науковий формат чисел (або ".6f" для звичайного)
))

# Виводимо значення похибки вимірювання логарифмічних декрементів
print(f"\nПохибка вимірювання логарифмічних декрементів = {round(delta_I_lambda_value, 4)}")
print(f"Похибка вимірювання логарифмічних декрементів вертикальної напруги = {round(delta_U_lambda_value, 4)}")